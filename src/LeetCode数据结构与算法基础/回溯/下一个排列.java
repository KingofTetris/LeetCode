package LeetCode数据结构与算法基础.回溯;

/**
 * @author by KingOfTetris
 * @date 2024/9/1
 */

import org.junit.Test;

import java.util.Arrays;
import java.util.regex.Pattern;

/**
 * 整数数组的一个 排列  就是将其所有成员以序列或线性顺序排列。
 * <p>
 * 例如，arr = [1,2,3] ，以下这些都可以视作 arr 的排列：[1,2,3]、[1,3,2]、[3,1,2]、[2,3,1] 。
 * 整数数组的 下一个排列 是指其整数的下一个字典序更大的排列。
 * 更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，
 * 那么数组的 下一个排列 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，
 * 那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。
 * <p>
 * 例如，arr = [1,2,3] 的下一个排列是 [1,3,2] 。
 * 类似地，arr = [2,3,1] 的下一个排列是 [3,1,2] 。
 * 而 arr = [3,2,1] 的下一个排列是 [1,2,3] ，因为 [3,2,1] 不存在一个字典序更大的排列。
 * 给你一个整数数组 nums ，找出 nums 的下一个排列。
 * <p>
 * 必须 原地 修改，只允许使用额外常数空间。
 */
public class 下一个排列 {

    //只是找下一个排列，不需要你全排列完在一个一个对比。
    @Test
    public void test() {
//        int[] nums = {1, 2, 3, 4, 5};
        int[] nums = {4,2,0,2,3,2,0};
        for (int i = 0; i < 1; i++) {
            nextPermutation(nums);
            System.out.println(Arrays.toString(nums));
        }
    }

    public void nextPermutation(int[] nums) {
        //找下一个排列的思路
        // 比如这一串数字里面
        //eg.12345
        //12345 -> 每次从尾巴开始向前找第一个比尾数小的数字，这里就是4，交换4和5，交换后得到12354
        // 排序5后面的元素，也就是4，得到12354

        //12354 -> 每次从尾巴开始向前找第一个比尾数小的数字，这里就是3，交换3和4，交换后得到12453
        // 排序4后面的元素，也就是53，得到12435

        //12435 -> 每次从尾巴开始向前找第一个比尾数小的数字，这里就是3，交换3和5，交换后得到12453
        // 排序5后面的元素，也就是3，得到12453

        //12453 -> 每次从尾巴开始向前找第一个比尾数小的数字，这里就是2，交换2和3，交换后得到13452
        // 排序3后面的元素，也就是452，得到13245

        //13245 -> 每次从尾巴开始向前找第一个比尾数小的数字，这里就是4，交换4和5，交换后得到13254
        //排序5后面的元素，也就是4，得到13254

        /** 如果尾巴已经是最小了，没得降了，那么尾巴就要往前推一位。**/

        //依次类推，当没有数字可以交换的时候，也就是从右到左依次升高，那就是最大的排列
        //这里就是54321，那么直接对整个数字进行排序就可以了
        //得到12345。

        //1.你首先要找到的是从后面往前面走，第一个左边小于右边的数字
        //让他们进行交换，这样才能进行提升

        //2.把交换过后的这个左边元素后面的数字进行排序，这样才能提升最少。


        //官解有O(N)的解法
        //https://leetcode.cn/problems/next-permutation/solutions/479151/xia-yi-ge-pai-lie-by-leetcode-solution/

        /**
         * 因为涉及到整个数组的排序，O(NlogN)。复杂度还是稍高了。但是这种写法最简单。
         */
        int n = nums.length;
        for (int i = n - 2; i >= 0; i--) {
            //j表示尾数，不能小于 i
            for (int j = n - 1; j > i; j--) {
                if (nums[j] > nums[i]){
                    swap(nums,i,j);
                    Arrays.sort(nums,i + 1,n);
                    return;
                }
            }
        }
        //如果出了这两个循环，说明这个排列已经是最大了。
        //重新排成最小就可以了。
        Arrays.sort(nums);
    }

    private void swap(int[] nums, int i, int j) {
        //交换两个元素
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }

}
