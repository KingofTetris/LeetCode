package 校招真题.腾讯.腾讯音乐娱乐集团2023技术类;

import org.junit.Test;

/**
 * @Author KingofTetris
 * @Date 2023/3/31 16:38
 *
 * 我们定义一个矩阵为“好矩阵”，当且仅当该矩阵所有2*2的子矩阵数字和为偶数。
 * 1 2 3
 * 2 3 4
 * 就是一个好矩阵，两个2*2的矩阵的和分贝是8和12
 * 请问n行m列，矩阵中每个数均在[1,x]范围内的好矩阵有多少组？
 * 答案可能过大，请对 1e9 + 7取模
 *
 * 2<=n,m,x<=1e9
 * 保证x为偶数 x为偶数保证了 [1,x]里面一定 一半是奇数，一半是偶数。
 */
public class 好矩阵 {



    /**
     * 一般来说和方案数有关的问题均为动态规划问题，但此题目数据范围1e9，
     * 显然不可能去模拟或者用平方级的规划，必然是一道找规律的题目，注意x为偶数。
     *
     * 所以先确定第一行
     * 第一行没有任何的限制，每个位置都有x种选择。因为无论怎么选都可以想办法让第二行任意2*2的矩阵满足要求
     * 为了方便分析，随意选择第一行的情况
     *
     * 第一行 如果是        奇偶奇....
     * 第二行也是          奇偶奇...
     * 也就是每行的元素奇偶性一致
     *
     * 第一行 如果是        奇偶奇....
     * 第二行是            偶奇偶...
     * 也就是每行的元素与上一行完全相反
     *
     * 这两种情况才能满足每个2*2的矩阵之和都是偶数
     *
     * 那么有了规律以后，要确定就是每个元素是奇数还是偶数，而由于x是偶数，那么奇数和偶数必然是各占一半也就是x/2，因此
     * 一二行完全一致的方案数就有 B = (x/2)^m
     * 一二行完全相反的方案同样也是 B = (x/2)^m
     * 所以第一行的方案总数就是 A = x^m ??这是怎么得来的?不是 2*(x/2)^m 吗
     *
     * 有了第一行，开始确定后面的二三四五六...n行
     *
     * 根据前面的规律，
     * 每行的奇偶性都和前一行一致，方案数就是 A * B
     * 每行都和前一行的奇偶性相反，方案数也是 A * B
     * 结果就是  AB + AB = 2AB = A * 2B
     * 所以每多一行就多乘一个2B
     * 而一共有n行，所以最后的结果数是 A * (2B)^(n-1)
     *
     * 而因为 n 和 m 都很大， n,m<=1e9
     * 所以整个问题变成了求一个数的幂。用到快速幂算法
     * 问题在于JDK8的Math.pow方法底层并不是用快速幂实现，而是通过调用系统库函数实现幂运算。
     * 当幂次很大的时候，就会溢出。
     * 所以除了Python以外的其他算法要自己实现快速幂，真恶心
     *
     * 另外相加相乘的时候就有可能会溢出，溢出就要取模
     * @return
     */

    @Test
    public void test(){
//        int i1 = fastPower(193243586, 999999930);
        int i = numsOfGoodMatrix(999999815, 999999930, 193243586);
        System.out.println(i);
    }
    int MOD = (int) (1e9 + 7);


    /**
     * 遇到这种参数很大的情况下。
     * 如果有相加相乘的情况发生，那么int是很有可能会溢出的。
     * java在相加相乘的前面往往要加上(long)进行强制转化完对MOD取余 然后再转回int
     *
     * 这就是除了Python外其他语言比较麻烦的地方，需要指定数据类型。
     * 而Python没有数据类型，也根本不会发生溢出。
     * 所以Python的缺点就是运行慢，内存占比大。但是程序员舒服。
     * @param n
     * @param m
     * @param x
     * @return
     */
    public int numsOfGoodMatrix (int n, int m, int x) {
        // write code here
        int A = fastPower(x,m),B = fastPower(x/2,m);
        int res = (int) (((long)A * fastPower(2*B,n-1)) % MOD); //小心这里也有可能int溢出，改成long
        return res;
    }

    public int fastPower(int x,int n){
        long result = 1;
        while (n > 0){
            if ((n & 1) == 1){ //如果n是奇数 1的二进制前面全是0，只有末尾是1也就是奇数才能相与得到1
                //奇数就要多乘一次底数
              result = (result * x) % MOD; //     *,/,%这三个运算符号的优先级是一样的
            }
            //偶数就直接base平方 因为 x * x 有可能会溢出int的范围，要强转成long才能防止溢出变成负数
            x = (int) (((long) x * x) % MOD);
            // n / 2
            //左移右移 固定小数点不动，移动数字
            n = n >> 1;
        }
        return (int) result;
    }
}
