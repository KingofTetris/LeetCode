package 设计模式.桥接模式;

/**
 * @author by KingOfTetris
 * @date 2024/11/9
 * <p>
 * <p>
 * 桥接是用于把抽象化与实现化解耦，使得二者可以独立变化。这种类型的设计模式属于结构型模式，
 * 它通过提供抽象化和实现化之间的桥接结构，来实现二者的解耦。
 * <p>
 * 字面的意思解读就是通过一个中间的桥梁对两边的东西进行关联起来，但是关联的两者之间又不相互影响。
 * 对这个印象比较深的是<大话设计模式>中的手机品牌和手机软件，手机有很多品牌，市场有很多软件，
 * 每个手机装的软件又各不相同，手机品牌包含包含软件，但是软件并不是手机的一部分，它们是聚合关系。
 * 如果A品牌手机装了a，b软件，B品牌手机装了b，c软件，如果A品牌手机需要新安装一个c软件，
 * 那么它只需添加该软件即可，无需知道该软件是如何生产的。相同的，如果新增了一个C品牌手机，
 * 那么它也只需安装所需的a、b或c软件即可。
 * <p>
 * <p>
 * <p>
 * 好了，废话不在多说，依旧用一个示例来进行说明。
 * 市面上有很多种笔，比如铅笔、黑色的圆珠笔和红色的圆珠笔等等， 也有很多种类型的纸，
 * 比如考试的卷子用的纸，报纸用的纸等等。一般来说，报纸上的字颜色是黑色的，
 * 这里我们就用黑色的圆珠笔来进行书写，考试卷子上的打分字颜色是红色的，这里我们就用红色的圆珠笔来进行书写。
 * 笔类和纸类相互独立，但是在纸上写字又将它们关联起来，这里我们就可以使用桥接模式。
 * <p>
 * 实现步骤如下:
 * <p>
 * 定义一个笔类的接口，有写的这个方法；
 * 定义红笔和黑笔的类，实现笔类的接口；
 * 定义一个纸类的抽象类，设置笔的种类，并需要实现被写的方法；
 * 定义卷子纸和新闻纸类，继承纸类并实现该方法；
 * 进行书写。
 */


/**
 *
 * 桥接是用于把抽象化与实现化解耦，使得二者可以独立变化。这种类型的设计模式属于结构型模式，
 * 它通过提供抽象化和实现化之间的桥接结构，来实现二者的解耦。
 *
 * 字面的意思解读就是通过一个中间的桥梁对两边的东西进行关联起来，但是关联的两者之间又不相互影响。
 * 对这个印象比较深的是<大话设计模式>中的手机品牌和手机软件，手机有很多品牌，市场有很多软件，
 * 每个手机装的软件又各不相同，手机品牌包含包含软件，但是软件并不是手机的一部分，它们是聚合关系。
 * 如果A品牌手机装了a，b软件，B品牌手机装了b，c软件，如果A品牌手机需要新安装一个c软件，
 * 那么它只需添加该软件即可，无需知道该软件是如何生产的。相同的，如果新增了一个C品牌手机，
 * 那么它也只需安装所需的a、b或c软件即可。
 *
 *
 *
 * 好了，废话不在多说，依旧用一个示例来进行说明。
 * 市面上有很多种笔，比如铅笔、黑色的圆珠笔和红色的圆珠笔等等， 也有很多种类型的纸，
 * 比如考试的卷子用的纸，报纸用的纸等等。一般来说，报纸上的字颜色是黑色的，
 * 这里我们就用黑色的圆珠笔来进行书写，考试卷子上的打分字颜色是红色的，这里我们就用红色的圆珠笔来进行书写。
 * 笔类和纸类相互独立，但是在纸上写字又将它们关联起来，这里我们就可以使用桥接模式。
 *
 * 实现步骤如下:
 *
 * 定义一个笔类的接口，有写的这个方法；
 * 定义红笔和黑笔的类，实现笔类的接口；
 * 定义一个纸类的抽象类，设置笔的种类，并需要实现被写的方法；
 * 定义卷子纸和新闻纸类，继承纸类并实现该方法；
 * 进行书写。
 */

//桥接模式和适配器模式非常类似。

/**
 * 桥接设计模式和适配器设计模式的共同点和明显，它们都是使两种不同的类配合工。
 *
 *        二者的区别在于，适配器模式是将已有的两个不同接口接口组合到一起，
 *        使得适配器同时拥有两个不同接口的功能，其目的是使两个不兼容的接口协调工作；
 *        桥接模式目的是抽象和实现分离，实现的改变不影响抽象，抽象的变化不影响实现，
 *        可以有效的应对具体业务的变化，以及业务实现的横向扩展。
 *
 * 但缺点会使系统看起复杂，对新手不友好，没有一定的抽象进行设计能力难以理解。
 * ————————————————
 *
 *                             版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。
 *
 * 原文链接：https://blog.csdn.net/fengchengwu2012/article/details/140144379
 */
public class BridgePattern {

    public static void main(String[] args) {
        Paper paper = new ExaminationPaper();
        paper.setPen(new RedPen());
        paper.writing();

        Paper paper2 = new NewsPaper();
        paper2.setPen(new BlackPen());
        paper2.writing();
    }
}

interface Pen {
    void write();
}

class RedPen implements Pen {
    @Override
    public void write() {
        System.out.println("红色的字");
    }
}

class BlackPen implements Pen {
    @Override
    public void write() {
        System.out.println("黑色的字");
    }
}


abstract class Paper {
    protected Pen pen;

    void setPen(Pen pen) {
        this.pen = pen;
    }

    abstract void writing();
}

class ExaminationPaper extends Paper {
    @Override
    void writing() {
        pen.write();
    }
}

class NewsPaper extends Paper {
    @Override
    void writing() {
        pen.write();
    }
}
