package LeetCode数据结构入门.day1.数组;

import org.junit.Test;

/**
 * @author KingofTetris
 * @File 有效的数独
 * @Time 2021/10/1  20:34
 */

/*
36. 有效的数独
        请你判断一个 9x9 的数独是否有效。只需要 根据以下规则 ，验证已经填入的数字是否有效即可。

        数字 1-9 在每一行只能出现一次。
        数字 1-9 在每一列只能出现一次。
        数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）
        数独部分空格内已填入了数字，空白格用 '.' 表示。

        注意：

        一个有效的数独（部分已被填充）不一定是可解的。
        只需要根据以上规则，验证已经填入的数字是否有效即可。*/

public class 有效的数独 {

    @Test
    public void test(){
        char[][]sudoku= {{'5','3','.','.','7','.','.','.','.'}
                        ,{'6','.','.','1','9','5','.','.','.'}
                        ,{'.','9','8','.','.','.','.','6','.'}
                        ,{'8','.','.','.','6','.','.','.','3'}
                        ,{'4','.','.','8','.','3','.','.','1'}
                        ,{'7','.','.','.','2','.','.','.','6'}
                        ,{'.','6','.','.','.','.','2','8','.'}
                        ,{'.','.','.','4','1','9','.','.','5'}
                        ,{'.','.','.','.','8','.','.','7','9'}};

//        System.out.println(isValidSudoku(sudoku));


    }

    //暴力判断 重点在于怎么判断出是哪个小格子
    // j/3 + i/3 *3

   /* 解题思路
    由于board中的整数限定在1到9的范围内，因此可以分别建立哈希表来存储任一个数在相应维度上是否出现过。维度有3个：所在的行，所在的列，所在的box，注意box的下标也是从左往右、从上往下的。

    遍历到每个数的时候，例如boar[i][j]，我们判断其是否满足三个条件：

    在第 i 个行中是否出现过
    在第 j 个列中是否出现过
    在第 j/3 + (i/3)*3个box中是否出现过.为什么是j/3 + (i/3)*3呢？
    关于从数组下标到box序号的变换
 重述一遍问题：给定i和j，如何判定board[i][j]在第几个box呢？
             显然属于第几个box由i和j的组合唯一确定，例如board[2][2]一定是第0个box，board[4][7]一定是第5个box，可以画出来看一下，但是规律在哪里呢？
    我们可以考虑一种简单的情况： 一个3x9的矩阵，被分成3个3x3的box，如图：


    显然每个数属于哪个box就只取决于纵坐标，纵坐标为0/1/2的都属于box[0],纵坐标为3/4/5的都属于box[1],纵坐标为6/7/8的都属于box[2].也就是j/3.
    而对于9x9的矩阵，我们光根据j/3得到0/1/2还是不够的，可能加上一个3的倍数，例如加0x3,表示本行的box，加1x3，表示在下一行的box，加2x3，表示在下两行的box， 这里的0/1/2怎么来的？和j/3差不多同理，也就是i/3。
    讲得不是很清楚，大家没懂的话自己再画图呗。
    注释也很详细，有收获求点赞！*/
//
//
//    int a = '.' - '0';
//        System.out.println(a);  a是-2
    public boolean isValidSudoku(char[][] board) {
        int[][] hang = new int[9][9];//判断行有没用重复1-9
        int[][] lie = new int[9][9];//列
        int[][] gezi = new int[9][9];//判断每个小的3*3 里面有没有重复


        //遍历一次二维数组
        for (int i = 0; i < 9; i++) {
            for (int j = 0; j < 9; j++) {

                //注意x是1-9 对应的下标要-1
                int x = board[i][j] - '0';

                //如果在1-9之间就在对应的行列和格子中
                if(x>=1&&x<=9){
                    hang[i][x-1]++;
                    lie[j][x-1]++;
                    //i/3*3 + j/3确定9个3*3小矩阵的位置 同样是从左往右 从上往下 0-8
                    //这样gezi的每行就代表一个小矩阵从0-8
                    //x-1 就可以记录小矩阵里面有没用重复的元素
                    gezi[i/3*3+j/3][x-1]++;
                    if(hang[i][x-1]>1||lie[j][x-1]>1||gezi[i/3*3+j/3][x-1]>1)
                        return false;
                }
            }
        }
        return true;
    }
}
