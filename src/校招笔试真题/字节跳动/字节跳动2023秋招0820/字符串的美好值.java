package 校招笔试真题.字节跳动.字节跳动2023秋招0820;

import java.util.Scanner;


//一个字符串的美好值为字符串内，连续相同子串的数量。例如“aabbccddef”的美好值为6。
//塔子哥的朋友给了他一个01串，已经迷恋上字符串的塔子哥想知道，这个01串所有子串的美好值之和是多少？

//连续相同子串?我们先拆分一下这个词主体是子串。然后要求是连续。
//连续子串，最后是相同。

//
/**
 * 样例
 * 输入
 * <p>
 * 4
 * 0011
 * 输出
 * <p>
 * 14
 * 说明
 * <p>
 * 子串分别为：0，0，1，1，00，01，11，001，011，0011
 * <p>
 * 美好值分别为：1，1，1，1，1，2，1，2，2，2
 * <p>
 * 总美好值为：14
 */
public class 字符串的美好值 {
    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);
        int n = scan.nextInt();
        long[] dp = new long[n];
        char[] arr = scan.next().toCharArray(); //转化为字符数组
        long ans;  // 定义一个长整型变量ans，用于存储最终的结果
        ans = dp[0] = 1;  //dp[i] 表示从字符串开头到位置 i（包括位置 i）的子串的美好值。

        /**
         * dp[0] = 1 ,一个字符就是1
         * //如果arr[i] == arr[i-1]
         * 说明出现了连续相同的字符，所以在前一个位置的美好值基础上再加 1。
         *
         * dp[i] = dp[i - 1] + 1
         *
         * //如果arr[i] != arr[i-1],说明出现了不同的字符，
         * 所以在前一个位置的美好值基础上加上当前位置 i 和 1，
         * 其中 i + 1 表示当前位置的子串中以当前字符结尾的美好值。
         *
         * dp[i] = dp[i - 1] + i + 1;
         *
         * 最后答案就是dp之和
         */
        for (int i = 1; i < n; i++) {  // 从第二个字符开始循环，直到最后一个字符
            if (arr[i] == arr[i - 1]){//如果后一个字符和前一个字符相同
                //说明是连续相同字串 就在前一个dp[i-1]的基础上+1
                dp[i] = dp[i - 1] + 1;
            }//如果不相同
            else {
              //如果后一个字符和前一个字符不同，那么dp[i] = dp[i - 1] + i + 1 //为什么是+i??
                // i + 1是当前新子串的长度。
            dp[i] = dp[i - 1] + i + 1;
            }
            ans += dp[i];  // 将当前位置的连续相同子串数量累加到ans中
        }
        System.out.println(ans);  // 输出最终结果
    }
}

/*作者：高启盛◎
链接：https://www.nowcoder.com/discuss/522934570560258048?sourceSSR=post
来源：牛客网*/
